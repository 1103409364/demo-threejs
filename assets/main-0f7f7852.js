var _=Object.defineProperty;var tt=(v,t,n)=>t in v?_(v,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):v[t]=n;var s=(v,t,n)=>(tt(v,typeof t!="symbol"?t+"":t,n),n);/* empty css              */import{V as H,aY as nt,c as ot,av as W,aa as j,a as T,S as et,A as st,a0 as J,P as it,W as rt,r as k,p as at,B as ct,b as lt,ac as K}from"./three.module-d5fa3ebf.js";import{S as ht}from"./Stats-ef6ecf20.js";import{G as pt}from"./lil-gui.esm-fc0b5e43.js";import{O as ut}from"./OrbitControls-5742bab2.js";import{g as dt}from"./index-539a094b.js";const m=class{constructor(){s(this,"polygons");this.polygons=[]}clone(){const t=new m;return t.polygons=this.polygons.map(function(n){return n.clone()}),t}toPolygons(){return this.polygons}union(t){const n=new P(this.clone().polygons),o=new P(t.clone().polygons);return n.clipTo(o),o.clipTo(n),o.invert(),o.clipTo(n),o.invert(),n.build(o.allPolygons()),m.fromPolygons(n.allPolygons())}subtract(t){const n=new P(this.clone().polygons),o=new P(t.clone().polygons);return n.invert(),n.clipTo(o),o.clipTo(n),o.invert(),o.clipTo(n),o.invert(),n.build(o.allPolygons()),n.invert(),m.fromPolygons(n.allPolygons())}intersect(t){const n=new P(this.clone().polygons),o=new P(t.clone().polygons);return n.invert(),o.clipTo(n),o.invert(),n.clipTo(o),o.clipTo(n),n.build(o.allPolygons()),n.invert(),m.fromPolygons(n.allPolygons())}inverse(){const t=this.clone();return t.polygons.map(function(n){n.flip()}),t}};let y=m;s(y,"fromPolygons",function(t){const n=new m;return n.polygons=t,n}),s(y,"fromGeometry",function(t,n){let o=[];const e=t.attributes.position,u=t.attributes.normal,l=t.attributes.uv,i=t.attributes.color;let d;if(t.index)d=t.index.array;else{d=new Array(e.array.length/e.itemSize|0);for(let h=0;h<d.length;h++)d[h]=h}const z=d.length/3|0;o=new Array(z);for(let h=0,f=0,g=d.length;h<g;h+=3,f++){const a=new Array(3);for(let r=0;r<3;r++){const c=d[h+r],p=c*3,w=c*2,A=e.array[p],R=e.array[p+1],q=e.array[p+2],E=u.array[p],Y=u.array[p+1],Z=u.array[p+2],D=l.array[w],$=l.array[w+1];a[r]=new F({x:A,y:R,z:q},{x:E,y:Y,z:Z},{x:D,y:$,z:0},i&&{x:i.array[w],y:i.array[w+1],z:i.array[w+2]})}o[f]=new B(a,n)}return m.fromPolygons(o)}),s(y,"ttvv0",new H),s(y,"tmpm3",new nt),s(y,"fromMesh",function(t,n){const o=m.fromGeometry(t.geometry,n);m.tmpm3.getNormalMatrix(t.matrix);for(let e=0;e<o.polygons.length;e++){const u=o.polygons[e];for(let l=0;l<u.vertices.length;l++){const i=u.vertices[l];i.pos.copy(m.ttvv0.copy(new H(i.pos.x,i.pos.y,i.pos.z)).applyMatrix4(t.matrix)),i.normal.copy(m.ttvv0.copy(new H(i.normal.x,i.normal.y,i.normal.z)).applyMatrix3(m.tmpm3))}}return o}),s(y,"nbuf3",t=>({top:0,array:new Float32Array(t),write:function(n){this.array[this.top++]=n.x,this.array[this.top++]=n.y,this.array[this.top++]=n.z}})),s(y,"nbuf2",t=>({top:0,array:new Float32Array(t),write:function(n){this.array[this.top++]=n.x,this.array[this.top++]=n.y}})),s(y,"toMesh",function(t,n,o){const e=t.polygons;let u=0;e.forEach(r=>u+=r.vertices.length-2);const l=new ot,i=m.nbuf3(u*3*3),d=m.nbuf3(u*3*3),z=m.nbuf2(u*2*3);let h;const f=[];if(e.forEach(r=>{const c=r.vertices,p=c.length;r.shared!==void 0&&(f[r.shared]||(f[r.shared]=[])),p&&c[0].color!==void 0&&(h||(h=m.nbuf3(u*3*3)));for(let w=3;w<=p;w++)r.shared!==void 0&&f[r.shared].push(i.top/3,i.top/3+1,i.top/3+2),i.write(c[0].pos),i.write(c[w-2].pos),i.write(c[w-1].pos),d.write(c[0].normal),d.write(c[w-2].normal),d.write(c[w-1].normal),z.write(c[0].uv),z.write(c[w-2].uv),z.write(c[w-1].uv),h&&(h.write(c[0].color)||h.write(c[w-2].color)||h.write(c[w-1].color))}),l.setAttribute("position",new W(i.array,3)),l.setAttribute("normal",new W(d.array,3)),l.setAttribute("uv",new W(z.array,2)),h&&l.setAttribute("color",new W(h.array,3)),f.length){let r=[],c=0;for(let p=0;p<f.length;p++)l.addGroup(c,f[p].length,p),c+=f[p].length,r=r.concat(f[p]);l.setIndex(r)}const g=new j().copy(n).invert();l.applyMatrix4(g),l.computeBoundingSphere(),l.computeBoundingBox();const a=new T(l,o);return a.matrix.copy(n),a.matrix.decompose(a.position,a.quaternion,a.scale),a.rotation.setFromQuaternion(a.quaternion),a.updateMatrixWorld(),a.castShadow=a.receiveShadow=!0,a});class N{constructor(t=0,n=0,o=0){s(this,"x");s(this,"y");s(this,"z");this.x=t,this.y=n,this.z=o}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}clone(){return new N(this.x,this.y,this.z)}negate(){return this.x*=-1,this.y*=-1,this.z*=-1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}times(t){return this.x*=t,this.y*=t,this.z*=t,this}dividedBy(t){return this.x/=t,this.y/=t,this.z/=t,this}lerp(t,n){return this.add(U.copy(t).sub(this).times(n))}unit(){return this.dividedBy(this.length())}length(){return Math.sqrt(this.x**2+this.y**2+this.z**2)}normalize(){return this.unit()}cross(t){const n=this,o=n.x,e=n.y,u=n.z,l=t.x,i=t.y,d=t.z;return this.x=e*d-u*i,this.y=u*l-o*d,this.z=o*i-e*l,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}}const U=new N(0,0,0),yt=new N(0,0,0);class F{constructor(t,n,o,e){s(this,"pos");s(this,"normal");s(this,"uv");s(this,"color");this.pos=new N().copy(t),this.normal=new N().copy(n),this.uv=new N().copy(o),this.uv.z=0,e&&(this.color=new N().copy(e))}clone(){return new F(this.pos,this.normal,this.uv,this.color)}flip(){this.normal.negate()}interpolate(t,n){return new F(this.pos.clone().lerp(t.pos,n),this.normal.clone().lerp(t.normal,n),this.uv.clone().lerp(t.uv,n),this.color&&t.color&&this.color.clone().lerp(t.color,n))}}const C=class{constructor(t,n){s(this,"normal");s(this,"w");this.normal=t,this.w=n}clone(){return new C(this.normal.clone(),this.w)}flip(){this.normal.negate(),this.w=-this.w}splitPolygon(t,n,o,e,u){let h=0;const f=[];for(let g=0;g<t.vertices.length;g++){const a=this.normal.dot(t.vertices[g].pos)-this.w,r=a<-C.EPSILON?2:a>C.EPSILON?1:0;h|=r,f.push(r)}switch(h){case 0:(this.normal.dot(t.plane.normal)>0?n:o).push(t);break;case 1:e.push(t);break;case 2:u.push(t);break;case 3:const g=[],a=[];for(let r=0;r<t.vertices.length;r++){const c=(r+1)%t.vertices.length,p=f[r],w=f[c],A=t.vertices[r],R=t.vertices[c];if(p!=2&&g.push(A),p!=1&&a.push(p!=2?A.clone():A),(p|w)==3){const q=(this.w-this.normal.dot(A.pos))/this.normal.dot(U.copy(R.pos).sub(A.pos)),E=A.interpolate(R,q);g.push(E),a.push(E.clone())}}g.length>=3&&e.push(new B(g,t.shared)),a.length>=3&&u.push(new B(a,t.shared));break}}};let G=C;s(G,"EPSILON",1e-5),s(G,"fromPoints",function(t,n,o){const e=U.copy(n).sub(t).cross(yt.copy(o).sub(t)).normalize();return new C(e.clone(),e.dot(t))});class B{constructor(t,n){s(this,"vertices");s(this,"shared");s(this,"plane");this.vertices=t,this.shared=n,this.plane=G.fromPoints(t[0].pos,t[1].pos,t[2].pos)}clone(){return new B(this.vertices.map(t=>t.clone()),this.shared)}flip(){this.vertices.reverse().map(t=>t.flip()),this.plane.flip()}}const O=class{constructor(t){s(this,"plane");s(this,"front");s(this,"back");s(this,"polygons");this.polygons=[],t&&this.build(t)}clone(){const t=new O;return t.plane=this.plane&&this.plane.clone(),t.front=this.front&&this.front.clone(),t.back=this.back&&this.back.clone(),t.polygons=this.polygons.map(n=>n.clone()),t}invert(){for(let n=0;n<this.polygons.length;n++)this.polygons[n].flip();this.plane&&this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();const t=this.front;this.front=this.back,this.back=t}clipPolygons(t){if(!this.plane)return t.slice();let n=[],o=[];for(let e=0;e<t.length;e++)this.plane.splitPolygon(t[e],n,o,n,o);return this.front&&(n=this.front.clipPolygons(n)),this.back?o=this.back.clipPolygons(o):o=[],n.concat(o)}clipTo(t){this.polygons=t.clipPolygons(this.polygons),this.front&&this.front.clipTo(t),this.back&&this.back.clipTo(t)}allPolygons(){let t=this.polygons.slice();return this.front&&(t=t.concat(this.front.allPolygons())),this.back&&(t=t.concat(this.back.allPolygons())),t}build(t){if(!t.length)return;this.plane||(this.plane=t[0].plane.clone());const n=[],o=[];for(let e=0;e<t.length;e++)this.plane.splitPolygon(t[e],this.polygons,this.polygons,n,o);n.length&&(this.front||(this.front=new O),this.front.build(n)),o.length&&(this.back||(this.back=new O),this.back.build(o))}};let P=O;s(P,"fromJSON",function(t){return y.fromPolygons(t.polygons.map(n=>new B(n.vertices.map(o=>new F(o.pos,o.normal,o.uv)),n.shared)))});const I=document.querySelector("#app"),b=new et;b.add(new st(5));const M=new J;M.position.set(2.5,5,5);M.angle=Math.PI/4;M.penumbra=.5;M.castShadow=!0;M.shadow.mapSize.width=1024;M.shadow.mapSize.height=1024;M.shadow.camera.near=.5;M.shadow.camera.far=20;b.add(M);const S=new J;S.position.set(-2.5,5,5);S.angle=Math.PI/4;S.penumbra=.5;S.castShadow=!0;S.shadow.mapSize.width=1024;S.shadow.mapSize.height=1024;S.shadow.camera.near=.5;S.shadow.camera.far=20;b.add(S);const x=new it(75,window.innerWidth/window.innerHeight,.1,1e3);x.position.x=.5;x.position.y=2;x.position.z=2.5;const L=new rt;L.setSize(window.innerWidth,window.innerHeight);I==null||I.appendChild(L.domElement);const wt=new ut(x,L.domElement),ft=new k({map:new at().load(dt("grid"))});{const v=new T(new ct(2,2,2),new k({color:16711680})),t=new T(new lt(1.45,8,8),new k({color:255})),n=new T(new K(.85,.85,2,8,1,!1),new k({color:65280})),o=new T(new K(.85,.85,2,8,1,!1),new k({color:65280})),e=new T(new K(.85,.85,2,8,1,!1),new k({color:65280}));v.position.set(-5,0,-6),b.add(v),t.position.set(-2,0,-6),b.add(t);const u=y.fromMesh(v),l=y.fromMesh(t),i=u.intersect(l),d=y.toMesh(i,new j);d.material=new k({color:16711935}),d.position.set(-2.5,0,-3),b.add(d),n.position.set(1,0,-6),b.add(n),o.position.set(3,0,-6),o.geometry.rotateX(Math.PI/2),b.add(o),e.position.set(5,0,-6),e.geometry.rotateZ(Math.PI/2),b.add(e);const z=y.fromMesh(n),h=y.fromMesh(o),f=y.fromMesh(e),g=z.union(h.union(f)),a=y.toMesh(g,new j);a.material=new k({color:16753920}),a.position.set(2.5,0,-3),b.add(a);const r=i.subtract(g),c=y.toMesh(r,new j);c.material=ft,b.add(c)}window.addEventListener("resize",mt,!1);function mt(){x.aspect=window.innerWidth/window.innerHeight,x.updateProjectionMatrix(),L.setSize(window.innerWidth,window.innerHeight),X()}const Q=new ht;I==null||I.appendChild(Q.dom);function V(){requestAnimationFrame(V),wt.update(),X(),Q.update()}function X(){L.render(b,x)}function gt(){const v=document.querySelector("#gui");if(!v)return;const n=new pt({container:v}).addFolder("Camera");n.add(x.position,"x",-10,10,.01),n.add(x.position,"y",-10,10,.01),n.add(x.position,"z",-10,10,.01)}gt();V();
