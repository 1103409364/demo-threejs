/* empty css              */import{V as m,bd as we,a8 as Z,be as Se,c as ke,ad as ue,a as te,S as Be,A as Ee,X as ge,P as qe,W as Le,a5 as _e,D as De,l as Ae,p as ye,i as He,C as Re,B as Ie,k as je,b as We,a_ as Ne}from"./three.module-d5fa3ebf.js";import{g as xe}from"./index-21dc82eb.js";import{W as Ge,P as Oe,a as ne,V as Pe,B as Ue,S as Xe}from"./cannon-es-36f8ef45.js";import{S as $e}from"./Stats-ef6ecf20.js";import{G as Ke}from"./lil-gui.esm-fc0b5e43.js";import{C as Qe}from"./cannonUtils-f382e6b3.js";import{P as Je}from"./PointerLockControls-6b92ec3d.js";import{R as Ye}from"./Reflector-a875886b.js";const ee=0,Ze=1,et=new m,pe=new we,ae=new Z,me=new m,J=new Se;class tt{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new fe,this.unassigned=new fe,this.vertices=[]}setFromPoints(e){if(e.length>=4){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.vertices.push(new nt(e[t]));this.compute()}return this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse(function(n){const o=n.geometry;if(o!==void 0){const s=o.attributes.position;if(s!==void 0)for(let i=0,a=s.count;i<a;i++){const c=new m;c.fromBufferAttribute(s,i).applyMatrix4(n.matrixWorld),t.push(c)}}}),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let n=0,o=t.length;n<o;n++)if(t[n].distanceToPoint(e)>this.tolerance)return!1;return!0}intersectRay(e,t){const n=this.faces;let o=-1/0,s=1/0;for(let i=0,a=n.length;i<a;i++){const c=n[i],r=c.distanceToPoint(e.origin),d=c.normal.dot(e.direction);if(r>0&&d>=0)return null;const p=d!==0?-r/d:0;if(!(p<=0)&&(d>0?s=Math.min(p,s):o=Math.max(p,o),o>s))return null}return o!==-1/0?e.at(o,t):e.at(s,t),t}intersectsRay(e){return this.intersectRay(e,et)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(e,t){return e.face=t,t.outside===null?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}removeVertexFromFace(e,t){return e===t.outside&&(e.next!==null&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}removeAllVerticesFromFace(e){if(e.outside!==null){const t=e.outside;let n=e.outside;for(;n.next!==null&&n.next.face===e;)n=n.next;return this.assigned.removeSubList(t,n),t.prev=n.next=null,e.outside=null,t}}deleteFaceVertices(e,t){const n=this.removeAllVerticesFromFace(e);if(n!==void 0)if(t===void 0)this.unassigned.appendChain(n);else{let o=n;do{const s=o.next;t.distanceToPoint(o.point)>this.tolerance?this.addVertexToFace(o,t):this.unassigned.append(o),o=s}while(o!==null)}return this}resolveUnassignedPoints(e){if(this.unassigned.isEmpty()===!1){let t=this.unassigned.first();do{const n=t.next;let o=this.tolerance,s=null;for(let i=0;i<e.length;i++){const a=e[i];if(a.mark===ee){const c=a.distanceToPoint(t.point);if(c>o&&(o=c,s=a),o>1e3*this.tolerance)break}}s!==null&&this.addVertexToFace(t,s),t=n}while(t!==null)}return this}computeExtremes(){const e=new m,t=new m,n=[],o=[];for(let s=0;s<3;s++)n[s]=o[s]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let s=0,i=this.vertices.length;s<i;s++){const a=this.vertices[s],c=a.point;for(let r=0;r<3;r++)c.getComponent(r)<e.getComponent(r)&&(e.setComponent(r,c.getComponent(r)),n[r]=a);for(let r=0;r<3;r++)c.getComponent(r)>t.getComponent(r)&&(t.setComponent(r,c.getComponent(r)),o[r]=a)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:n,max:o}}computeInitialHull(){const e=this.vertices,t=this.computeExtremes(),n=t.min,o=t.max;let s=0,i=0;for(let l=0;l<3;l++){const g=o[l].point.getComponent(l)-n[l].point.getComponent(l);g>s&&(s=g,i=l)}const a=n[i],c=o[i];let r,d;s=0,pe.set(a.point,c.point);for(let l=0,g=this.vertices.length;l<g;l++){const y=e[l];if(y!==a&&y!==c){pe.closestPointToPoint(y.point,!0,me);const f=me.distanceToSquared(y.point);f>s&&(s=f,r=y)}}s=-1,ae.setFromCoplanarPoints(a.point,c.point,r.point);for(let l=0,g=this.vertices.length;l<g;l++){const y=e[l];if(y!==a&&y!==c&&y!==r){const f=Math.abs(ae.distanceToPoint(y.point));f>s&&(s=f,d=y)}}const p=[];if(ae.distanceToPoint(d.point)<0){p.push(b.create(a,c,r),b.create(d,c,a),b.create(d,r,c),b.create(d,a,r));for(let l=0;l<3;l++){const g=(l+1)%3;p[l+1].getEdge(2).setTwin(p[0].getEdge(g)),p[l+1].getEdge(1).setTwin(p[g+1].getEdge(0))}}else{p.push(b.create(a,r,c),b.create(d,a,c),b.create(d,c,r),b.create(d,r,a));for(let l=0;l<3;l++){const g=(l+1)%3;p[l+1].getEdge(2).setTwin(p[0].getEdge((3-l)%3)),p[l+1].getEdge(0).setTwin(p[g+1].getEdge(1))}}for(let l=0;l<4;l++)this.faces.push(p[l]);for(let l=0,g=e.length;l<g;l++){const y=e[l];if(y!==a&&y!==c&&y!==r&&y!==d){s=this.tolerance;let f=null;for(let x=0;x<4;x++){const k=this.faces[x].distanceToPoint(y.point);k>s&&(s=k,f=this.faces[x])}f!==null&&this.addVertexToFace(y,f)}}return this}reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const n=this.faces[t];n.mark===ee&&e.push(n)}return this.faces=e,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let e,t=0;const n=this.assigned.first().face;let o=n.outside;do{const s=n.distanceToPoint(o.point);s>t&&(t=s,e=o),o=o.next}while(o!==null&&o.face===n);return e}}computeHorizon(e,t,n,o){this.deleteFaceVertices(n),n.mark=Ze;let s;t===null?s=t=n.getEdge(0):s=t.next;do{const i=s.twin,a=i.face;a.mark===ee&&(a.distanceToPoint(e)>this.tolerance?this.computeHorizon(e,i,a,o):o.push(s)),s=s.next}while(s!==t);return this}addAdjoiningFace(e,t){const n=b.create(e,t.tail(),t.head());return this.faces.push(n),n.getEdge(-1).setTwin(t.twin),n.getEdge(0)}addNewFaces(e,t){this.newFaces=[];let n=null,o=null;for(let s=0;s<t.length;s++){const i=t[s],a=this.addAdjoiningFace(e,i);n===null?n=a:a.next.setTwin(o),this.newFaces.push(a.face),o=a}return n.next.setTwin(o),this}addVertexToHull(e){const t=[];return this.unassigned.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let e;for(this.computeInitialHull();(e=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(e);return this.reindexFaces(),this.cleanup(),this}}class b{constructor(){this.normal=new m,this.midpoint=new m,this.area=0,this.constant=0,this.outside=null,this.mark=ee,this.edge=null}static create(e,t,n){const o=new b,s=new re(e,o),i=new re(t,o),a=new re(n,o);return s.next=a.prev=i,i.next=s.prev=a,a.next=i.prev=s,o.edge=s,o.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),n=this.edge.next.head();return J.set(e.point,t.point,n.point),J.getNormal(this.normal),J.getMidpoint(this.midpoint),this.area=J.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class re{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class nt{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class fe{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,t.prev===null?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,t.next===null?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail;e.next!==null;)e=e.next;return this.tail=e,this}remove(e){return e.prev===null?this.head=e.next:e.prev.next=e.next,e.next===null?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return e.prev===null?this.head=t.next:e.prev.next=t.next,t.next===null?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return this.head===null}}class le extends ke{constructor(e=[]){super();const t=[],n=[],s=new tt().setFromPoints(e).faces;for(let i=0;i<s.length;i++){const a=s[i];let c=a.edge;do{const r=c.head().point;t.push(r.x,r.y,r.z),n.push(a.normal.x,a.normal.y,a.normal.z),c=c.next}while(c!==a.edge)}this.setAttribute("position",new ue(t,3)),this.setAttribute("normal",new ue(n,3))}}const st=new m;class ${constructor(e=1.4,t=1e-4){this.minSizeForBreak=e,this.smallDelta=t,this.tempLine1=new we,this.tempPlane1=new Z,this.tempPlane2=new Z,this.tempPlane_Cut=new Z,this.tempCM1=new m,this.tempCM2=new m,this.tempVector3=new m,this.tempVector3_2=new m,this.tempVector3_3=new m,this.tempVector3_P0=new m,this.tempVector3_P1=new m,this.tempVector3_P2=new m,this.tempVector3_N0=new m,this.tempVector3_N1=new m,this.tempVector3_AB=new m,this.tempVector3_CB=new m,this.tempResultObjects={object1:null,object2:null},this.segments=[];const n=30*30;for(let o=0;o<n;o++)this.segments[o]=!1}prepareBreakableObject(e,t,n,o,s){const i=e.userData;i.mass=t,i.velocity=n.clone(),i.angularVelocity=o.clone(),i.breakable=s}subdivideByImpact(e,t,n,o,s){const i=[],a=this.tempPlane1,c=this.tempPlane2;this.tempVector3.addVectors(t,n),a.setFromCoplanarPoints(t,e.position,this.tempVector3);const r=s+o,d=this;function p(l,g,y,f){if(Math.random()<f*.05||f>r){i.push(l);return}let x=Math.PI;f===0?(c.normal.copy(a.normal),c.constant=a.constant):f<=o?(x=(y-g)*(.2+.6*Math.random())+g,d.tempVector3_2.copy(e.position).sub(t).applyAxisAngle(n,x).add(t),c.setFromCoplanarPoints(t,d.tempVector3,d.tempVector3_2)):(x=(.5*(f&1)+.2*(2-Math.random()))*Math.PI,d.tempVector3_2.copy(t).sub(l.position).applyAxisAngle(n,x).add(l.position),d.tempVector3_3.copy(n).add(l.position),c.setFromCoplanarPoints(l.position,d.tempVector3_3,d.tempVector3_2)),d.cutByPlane(l,c,d.tempResultObjects);const k=d.tempResultObjects.object1,I=d.tempResultObjects.object2;k&&p(k,g,x,f+1),I&&p(I,x,y,f+1)}return p(e,0,2*Math.PI,0),i}cutByPlane(e,t,n){const o=e.geometry,s=o.attributes.position.array,i=o.attributes.normal.array,a=s.length/3;let c=a/3,r=o.getIndex();r&&(r=r.array,c=r.length/3);function d(u,w){const P=u*3+w;return r?r[P]:P}const p=[],l=[],g=this.smallDelta,y=a*a;for(let u=0;u<y;u++)this.segments[u]=!1;const f=this.tempVector3_P0,x=this.tempVector3_P1,k=this.tempVector3_N0,I=this.tempVector3_N1;for(let u=0;u<c-1;u++){const w=d(u,0),P=d(u,1),q=d(u,2);k.set(i[w],i[w]+1,i[w]+2);for(let V=u+1;V<c;V++){const M=d(V,0),C=d(V,1),Q=d(V,2);I.set(i[M],i[M]+1,i[M]+2),1-k.dot(I)<g&&(w===M||w===C||w===Q?P===M||P===C||P===Q?(this.segments[w*a+P]=!0,this.segments[P*a+w]=!0):(this.segments[q*a+w]=!0,this.segments[w*a+q]=!0):(P===M||P===C||P===Q)&&(this.segments[q*a+P]=!0,this.segments[P*a+q]=!0))}}const K=this.tempPlane_Cut;e.updateMatrix(),$.transformPlaneToLocalSpace(t,e.matrix,K);for(let u=0;u<c;u++){const w=d(u,0),P=d(u,1),q=d(u,2);for(let V=0;V<3;V++){const M=V===0?w:V===1?P:q,C=V===0?P:V===1?q:w;if(this.segments[M*a+C])continue;this.segments[M*a+C]=!0,this.segments[C*a+M]=!0,f.set(s[3*M],s[3*M+1],s[3*M+2]),x.set(s[3*C],s[3*C+1],s[3*C+2]);let D=0,O=K.distanceToPoint(f);O>g?(D=2,l.push(f.clone())):O<-g?(D=1,p.push(f.clone())):(D=3,p.push(f.clone()),l.push(f.clone()));let U=0;if(O=K.distanceToPoint(x),O>g?(U=2,l.push(x.clone())):O<-g?(U=1,p.push(x.clone())):(U=3,p.push(x.clone()),l.push(x.clone())),D===1&&U===2||D===2&&U===1){this.tempLine1.start.copy(f),this.tempLine1.end.copy(x);let X=new m;if(X=K.intersectLine(this.tempLine1,X),X===null)return console.error("Internal error: segment does not intersect plane."),n.segmentedObject1=null,n.segmentedObject2=null,0;p.push(X),l.push(X.clone())}}}const de=e.userData.mass*.5;this.tempCM1.set(0,0,0);let se=0;const j=p.length;if(j>0){for(let u=0;u<j;u++)this.tempCM1.add(p[u]);this.tempCM1.divideScalar(j);for(let u=0;u<j;u++){const w=p[u];w.sub(this.tempCM1),se=Math.max(se,w.x,w.y,w.z)}this.tempCM1.add(e.position)}this.tempCM2.set(0,0,0);let ie=0;const W=l.length;if(W>0){for(let u=0;u<W;u++)this.tempCM2.add(l[u]);this.tempCM2.divideScalar(W);for(let u=0;u<W;u++){const w=l[u];w.sub(this.tempCM2),ie=Math.max(ie,w.x,w.y,w.z)}this.tempCM2.add(e.position)}let N=null,G=null,oe=0;return j>4&&(N=new te(new le(p),e.material),N.position.copy(this.tempCM1),N.quaternion.copy(e.quaternion),this.prepareBreakableObject(N,de,e.userData.velocity,e.userData.angularVelocity,2*se>this.minSizeForBreak),oe++),W>4&&(G=new te(new le(l),e.material),G.position.copy(this.tempCM2),G.quaternion.copy(e.quaternion),this.prepareBreakableObject(G,de,e.userData.velocity,e.userData.angularVelocity,2*ie>this.minSizeForBreak),oe++),n.object1=N,n.object2=G,oe}static transformFreeVector(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[4]*o+i[8]*s,e.y=i[1]*n+i[5]*o+i[9]*s,e.z=i[2]*n+i[6]*o+i[10]*s,e}static transformFreeVectorInverse(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[1]*o+i[2]*s,e.y=i[4]*n+i[5]*o+i[6]*s,e.z=i[8]*n+i[9]*o+i[10]*s,e}static transformTiedVectorInverse(e,t){const n=e.x,o=e.y,s=e.z,i=t.elements;return e.x=i[0]*n+i[1]*o+i[2]*s-i[12],e.y=i[4]*n+i[5]*o+i[6]*s-i[13],e.z=i[8]*n+i[9]*o+i[10]*s-i[14],e}static transformPlaneToLocalSpace(e,t,n){n.normal.copy(e.normal),n.constant=e.constant;const o=$.transformTiedVectorInverse(e.coplanarPoint(st),t);$.transformFreeVectorInverse(n.normal,t),n.constant=-o.dot(n.normal)}}const H=document.querySelector("#app"),S=new Be;S.add(new Ee(5));const ve=new ge;ve.position.set(20,20,20);S.add(ve);const Me=new ge;Me.position.set(-20,20,20);S.add(Me);const v=new qe(75,window.innerWidth/window.innerHeight,.1,1e3);v.position.set(0,4,4);const R=new Le;R.setSize(window.innerWidth,window.innerHeight);H==null||H.appendChild(R.domElement);const Ve=document.getElementById("menuPanel"),it=document.getElementById("startButton");it.addEventListener("click",function(){B.lock()},!1);const B=new Je(v,R.domElement);B.addEventListener("lock",()=>Ve.style.display="none");B.addEventListener("unlock",()=>Ve.style.display="block");v.position.y=1;v.position.z=2;const ot=function(h){switch(h.key){case"w":B.moveForward(.25);break;case"a":B.moveRight(-.25);break;case"s":B.moveForward(-.25);break;case"d":B.moveRight(.25);break}};document.addEventListener("keydown",ot,!1);const E=new Ge;E.gravity.set(0,-9.82,0);const Fe=new _e({color:16777215,metalness:1,roughness:.25,transparent:!0,opacity:.75,side:De}),at=new Ae(R),rt=new ye().load(xe("pano-equirectangular","jpg"),()=>{Fe.envMap=at.fromEquirectangular(rt).texture}),T={},F={};let A=0;const ce=new Ye(new He(1024,1024),{color:new Re(2236962),clipBias:.003,textureWidth:window.innerWidth*window.devicePixelRatio,textureHeight:window.innerHeight*window.devicePixelRatio});ce.position.y=-.05;ce.rotateX(-Math.PI/2);S.add(ce);const lt=new Oe,he=new ne({mass:0});he.addShape(lt);he.quaternion.setFromAxisAngle(new Pe(1,0,0),-Math.PI/2);E.addBody(he);const be=new $;for(let h=0;h<20;h++){const e={x:Math.random()*4+2,y:Math.random()*10+5,z:Math.random()*4+2},t=new Ie(e.x,e.y,e.z),n=new te(t,Fe);n.position.x=Math.random()*50-25,n.position.y=e.y/2+.1,n.position.z=Math.random()*50-25,S.add(n),T[A]=n,be.prepareBreakableObject(T[A],1,new m,new m,!0);const o=new Ue(new Pe(e.x/2,e.y/2,e.z/2)),s=new ne({mass:1});s.userData={splitCount:0,id:A},s.addShape(o),s.position.x=n.position.x,s.position.y=n.position.y,s.position.z=n.position.z,E.addBody(s),F[A]=s,A++}const _={},z={};let L=0;const ct=new je({map:new ye().load(xe("marble")),clearcoat:1,clearcoatRoughness:0,clearcoatMap:null,clearcoatRoughnessMap:null,metalness:.4,roughness:.3,color:"white"});document.addEventListener("click",ht,!1);function ht(){if(B.isLocked){const h=new te(new We(1,16,16),ct);h.position.copy(v.position),S.add(h),_[L]=h;const e=new Xe(1),t=new ne({mass:1});t.addShape(e),t.position.x=v.position.x,t.position.y=v.position.y,t.position.z=v.position.z,E.addBody(t),z[L]=t,t.addEventListener("collide",o=>{o.body.userData&&o.body.userData.splitCount<2&&dt(o.body.userData,o.contact)});const n=new m(0,0,-1);for(n.applyQuaternion(v.quaternion),n.multiplyScalar(50),t.velocity.set(n.x,n.y,n.z),t.angularVelocity.set(Math.random()*10+1,Math.random()*10+1,Math.random()*10+1),L++;Object.keys(_).length>5;)S.remove(_[L-6]),delete _[L-6],E.removeBody(z[L-6]),delete z[L-6]}}function dt(h,e){const t=h.id;if(T[t]){const n=F[t].pointToLocalFrame(e.bj.position.vadd(e.rj)),o=new m(e.ni.x,e.ni.y,e.ni.z).negate(),s=be.subdivideByImpact(T[t],new m(n.x,n.y,n.z),o,1,0);S.remove(T[t]),delete T[t],E.removeBody(F[t]),delete F[t],s.forEach(i=>{const a=A++;S.add(i),T[a]=i,i.geometry.scale(.99,.99,.99);const c=ut(i.geometry),r=new ne({mass:1});r.addShape(c),r.userData={splitCount:h.splitCount+1,id:a},r.position.x=i.position.x,r.position.y=i.position.y,r.position.z=i.position.z,r.quaternion.x=i.quaternion.x,r.quaternion.y=i.quaternion.y,r.quaternion.z=i.quaternion.z,r.quaternion.w=i.quaternion.w,E.addBody(r),F[a]=r})}}function ut(h){const e=h.attributes.position.array,t=[];for(let s=0;s<e.length;s+=3)t.push(new m(e[s],e[s+1],e[s+2]));const n=new le(t);return Qe.CreateConvexPolyhedron(n)}window.addEventListener("resize",pt,!1);function pt(){v.aspect=window.innerWidth/window.innerHeight,v.updateProjectionMatrix(),R.setSize(window.innerWidth,window.innerHeight),Te()}const Ce=new $e;H==null||H.appendChild(Ce.dom);const mt=new Ne;let Y;function ze(){requestAnimationFrame(ze),Y=mt.getDelta(),Y>.1&&(Y=.1),E.step(Y),Object.keys(T).forEach(h=>{T[h].position.set(F[h].position.x,F[h].position.y,F[h].position.z),T[h].quaternion.set(F[h].quaternion.x,F[h].quaternion.y,F[h].quaternion.z,F[h].quaternion.w)}),Object.keys(_).forEach(h=>{_[h].position.set(z[h].position.x,z[h].position.y,z[h].position.z),_[h].quaternion.set(z[h].quaternion.x,z[h].quaternion.y,z[h].quaternion.z,z[h].quaternion.w)}),Te(),Ce.update()}function Te(){R.render(S,v)}function ft(){const h=document.querySelector("#gui");if(!h)return;const t=new Ke({container:h}).addFolder("Camera");t.add(v.position,"x",-10,10,.01),t.add(v.position,"y",-10,10,.01),t.add(v.position,"z",-10,10,.01)}ft();ze();
